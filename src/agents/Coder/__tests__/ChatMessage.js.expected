import stringWidth from "string-width"
import Prompt from "../../../lib/chat/Prompt.js"

/**
 * @extends {Prompt}
 * @property {string} username
 */
class ChatMessage extends Prompt {
	static ELEMENTS_OF = [ChatMessage]
	static ROLES = [...Prompt.ROLES, 'os']
	static PROPERTIES = {
		...Prompt.PROPERTIES,
		username: String,
	}
	static DEFAULTS = {
		...Prompt.DEFAULTS,
	}
	static SAVE_FIRST_PROP = "username"
	static SHORT_ROLES_ALIASES = {
		"user": "usr"
	}
	/**
	 * @type {string}
	 */
	username

	constructor(username = "", props = {}) {
		const {
			role = Prompt.DEFAULTS.role ?? "user"
		} = props
		super(role, props)
		this.username = props?.username ?? username
	}

	/**
	 * Adds a nested message to the current instance.
	 * @param {ChatMessage} message - The element to add (can be an object or string).
	 * @param {string|null} field - An optional grouping field.
	 * @param {Record<string, any>} defaultValues - Optional default values for the element.
	 * @returns {ChatMessage} - Added element.
	 */
	add(message, field = null, defaultValues = {}) {
		super.add(message, field, defaultValues)
		const arr = this.getElements()
		return arr[arr.length - 1]
	}

	/**
	 * @param {object} [props={}]
	 * @param {boolean|string} [props.format=false] - true or "short" for aligned output.
	 * @param {boolean} [props.avoidTags=false]
	 * @param {number} [props.level=0]
	 * @param {string} [props.tab=""]
	 * @param {number[]} [props.columns] - Custom column widths: [role, username, content]
	 * @param {number} [props.padding=1] - Spacing between columns
	 * @returns {string}
	 */
	toString({
		format = false,
		avoidTags = false,
		level = 0,
		tab = "",
		columns,
		padding = 1
	} = {}) {
		const short = format === "short"
		const formatted = !!format

		const self = /** @type {typeof ChatMessage} */ (this.constructor)
		const flat = this.getFlat()

		let roleWidth = short ? 3 : 9
		let userWidth = 0
		let contentWidth = 0

		if (formatted && !columns) {
			for (const { element } of flat) {
				let role = short ? (self.SHORT_ROLES_ALIASES?.[element.role] ?? element.role.slice(0, 3)) : element.role
				let user = element.username ?? ""
				let content = element.content ?? ""
				roleWidth = Math.max(roleWidth, stringWidth(role))
				userWidth = Math.max(userWidth, stringWidth(user))
				contentWidth = Math.max(contentWidth, stringWidth(content))
			}
		} else if (Array.isArray(columns)) {
			[roleWidth, userWidth, contentWidth] = columns
		}

		const pad = (s, w) => s.padEnd(w)
		const lines = flat.map(({ element }) => {
			let role = short ? (self.SHORT_ROLES_ALIASES?.[element.role] ?? element.role.slice(0, 3)) : element.role
			let user = element.username ?? ""
			let content = element.content ?? ""

			if (!formatted) {
				let label = element.role + (element.username ? ` @${element.username}` : "")
				return `${label}:\n${content}`
			}

			let prefix = [pad(role, roleWidth)]
			if (user) prefix.push("@" + pad(user, userWidth))
			let pre = prefix.join(" ")
			const label = pad(pre, roleWidth + userWidth) // Remove the extra space before colon
			const fullLabel = label + ":" // Add colon without padding

			const wrapped = content.match(new RegExp(`.{1,${contentWidth}}`, "g")) || []
			return wrapped.map((line, i) => i === 0 ? fullLabel + line : " ".repeat(fullLabel.length) + line).join("\n")
		})

		return lines.join("\n\n")
	}

	/**
	 * @param {Function[]} classes
	 * @returns {ChatMessage[]}
	 */
	getElements(classes = []) {
		// @todo fix: Type 'NANOElement[]' is not assignable to type 'ChatMessage[]'.
		//   Type 'NANOElement' is missing the following properties from type 'ChatMessage': username, getFlat, role, content, toArrayts(2322)
		return super.getElements(classes)
	}

	/**
	 * @param {object} [props={}]
	 * @returns {ChatMessage}
	 */
	static from(props = {}) {
		return new this(props.username, props)
	}

	/**
	 * @returns {Array<{element: ChatMessage, level: number}>}
	 */
	getFlat({ level = 0 } = { level: 0 }) {
		const arr = []
		arr.push({ element: this, level })
		for (const el of this.getElements()) {
			for (const child of el.getFlat({ level: level + 1 })) {
				arr.push(child)
			}
		}
		return arr
	}
}

export default ChatMessage
